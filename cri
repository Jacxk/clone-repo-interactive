#!/usr/bin/env python3

import argparse
import curses
import json
import os
import shutil
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timezone


@dataclass
class Repo:
    name: str
    full_name: str
    description: str
    search_text: str
    updated_at: str
    visibility: str
    is_private: bool


def run_gh_json(args: list[str]) -> list[dict]:
    try:
        proc = subprocess.run(
            ["gh", *args],
            capture_output=True,
            text=True,
            check=True,
        )
    except FileNotFoundError:
        print("Error: GitHub CLI 'gh' is not installed or not in PATH.", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as exc:
        err = exc.stderr.strip() or exc.stdout.strip() or str(exc)
        print(f"Error running gh command: {err}", file=sys.stderr)
        sys.exit(1)

    try:
        return json.loads(proc.stdout)
    except json.JSONDecodeError:
        print("Error: Failed to parse JSON returned by gh.", file=sys.stderr)
        sys.exit(1)


def get_authenticated_login() -> str | None:
    try:
        proc = subprocess.run(
            ["gh", "api", "user", "--jq", ".login"],
            capture_output=True,
            text=True,
            check=True,
        )
    except (FileNotFoundError, subprocess.CalledProcessError):
        return None
    login = proc.stdout.strip()
    return login or None


def fetch_repositories(owner: str | None) -> list[Repo]:
    args = ["repo", "list"]
    if owner:
        args.append(owner)
    args.extend(
        [
            "--limit",
            "1000",
            "--json",
            "name,nameWithOwner,description,pushedAt,updatedAt,visibility,isPrivate",
        ]
    )

    rows = run_gh_json(args)
    repos = [
        Repo(
            name=row["name"],
            full_name=row["nameWithOwner"],
            description=(row.get("description") or "").strip(),
            search_text=" ".join(
                [
                    row["name"],
                    row["nameWithOwner"],
                    (row.get("description") or ""),
                ]
            ).lower(),
            updated_at=row.get("pushedAt") or row.get("updatedAt") or "",
            visibility=row.get("visibility", "UNKNOWN"),
            is_private=bool(row.get("isPrivate", False)),
        )
        for row in rows
    ]

    me = get_authenticated_login()
    if owner and (not me or owner.lower() != me.lower()):
        repos = [r for r in repos if not r.is_private and r.visibility.upper() == "PUBLIC"]

    repos.sort(key=lambda r: r.updated_at, reverse=True)
    return repos


def _match_repos(repos: list[Repo], query: str) -> list[Repo]:
    if not query:
        return repos
    q = query.lower()
    return [repo for repo in repos if q in repo.search_text]


def _safe_add(stdscr, y: int, x: int, text: str, width: int, attr: int = 0) -> None:
    if width <= 0:
        return
    try:
        stdscr.addnstr(y, x, text, width, attr)
    except curses.error:
        pass


def _draw_with_highlight(stdscr, y: int, x: int, text: str, width: int, query: str, base_attr: int, match_attr: int) -> None:
    clipped = text[: max(0, width)]
    if not clipped:
        return
    _safe_add(stdscr, y, x, clipped, width, base_attr)
    if not query:
        return

    q = query.lower()
    lower_text = clipped.lower()
    start = 0
    while True:
        idx = lower_text.find(q, start)
        if idx == -1:
            break
        _safe_add(
            stdscr,
            y,
            x + idx,
            clipped[idx : idx + len(query)],
            max(0, width - idx),
            base_attr | match_attr,
        )
        start = idx + len(query)


def _truncate(text: str, width: int) -> str:
    if width <= 0:
        return ""
    if len(text) <= width:
        return text
    if width == 1:
        return text[:1]
    return text[: width - 1] + "..."


def _format_relative_time(iso_time: str) -> str:
    if not iso_time:
        return "unknown"
    try:
        parsed = datetime.fromisoformat(iso_time.replace("Z", "+00:00"))
    except ValueError:
        return iso_time[:10]
    now = datetime.now(timezone.utc)
    if parsed.tzinfo is None:
        parsed = parsed.replace(tzinfo=timezone.utc)
    delta = now - parsed
    seconds = int(max(0, delta.total_seconds()))
    if seconds < 60:
        return "just now"
    if seconds < 3600:
        return f"{seconds // 60}m ago"
    if seconds < 86400:
        return f"{seconds // 3600}h ago"
    if seconds < 86400 * 30:
        return f"{seconds // 86400}d ago"
    if seconds < 86400 * 365:
        return f"{seconds // (86400 * 30)}mo ago"
    return f"{seconds // (86400 * 365)}y ago"


def _description_view(text: str, offset: int, width: int) -> str:
    if width <= 0:
        return ""
    if not text:
        return ""

    safe_offset = max(0, min(offset, len(text)))
    show_right = safe_offset + width < len(text)
    if not show_right:
        return text[safe_offset : safe_offset + width]
    if width <= 3:
        return "." * width
    return text[safe_offset : safe_offset + width - 3] + "..."


def _chooser(stdscr, repos: list[Repo]) -> Repo | None:
    curses.curs_set(0)
    stdscr.keypad(True)
    if curses.has_colors():
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_CYAN)   # header
        curses.init_pair(2, curses.COLOR_CYAN, -1)                   # accents
        curses.init_pair(3, curses.COLOR_YELLOW, -1)                 # matches
        curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_WHITE)  # selected row
        curses.init_pair(5, curses.COLOR_GREEN, -1)                  # badges
        header_attr = curses.color_pair(1) | curses.A_BOLD
        accent_attr = curses.color_pair(2) | curses.A_BOLD
        match_attr = curses.color_pair(3) | curses.A_BOLD
        selected_attr = curses.color_pair(4) | curses.A_BOLD
        badge_attr = curses.color_pair(5) | curses.A_BOLD
    else:
        header_attr = curses.A_REVERSE | curses.A_BOLD
        accent_attr = curses.A_BOLD
        match_attr = curses.A_BOLD
        selected_attr = curses.A_REVERSE | curses.A_BOLD
        badge_attr = curses.A_BOLD

    selected = 0
    offset = 0
    query = ""
    desc_offsets: dict[str, int] = {}

    while True:
        height, width = stdscr.getmaxyx()
        stdscr.erase()

        filtered = _match_repos(repos, query)
        if selected >= len(filtered):
            selected = max(0, len(filtered) - 1)
        if filtered:
            offset = min(offset, max(0, len(filtered) - 1))
        else:
            offset = 0

        if height < 10 or width < 40:
            msg = "Terminal too small. Resize to at least 40x10."
            _safe_add(stdscr, 0, 0, msg, max(1, width - 1))
            stdscr.refresh()
            key = stdscr.getch()
            if key in (ord("q"), 27):
                return None
            continue

        title = " CRI  Clone Repository Interactive "
        _safe_add(stdscr, 0, 0, " " * max(1, width - 1), max(1, width - 1), header_attr)
        _safe_add(stdscr, 0, 0, _truncate(title, width - 1), max(1, width - 1), header_attr)

        subtitle = f"Repos: {len(repos)}  Matches: {len(filtered)}"
        _safe_add(stdscr, 1, 0, _truncate(subtitle, width - 1), max(1, width - 1), accent_attr)

        search_label = "Search"
        search_value = query if query else "Type to filter repositories"
        search_attr = curses.A_DIM if not query else curses.A_NORMAL
        _safe_add(stdscr, 2, 0, f"{search_label}: ", max(1, width - 1), accent_attr)
        _safe_add(stdscr, 2, len(search_label) + 2, _truncate(search_value, width - len(search_label) - 3), max(1, width - len(search_label) - 3), search_attr)

        vis_col_width = 10
        updated_col_width = 14
        col_gap = 3
        vis_x = max(0, width - vis_col_width - 1)
        updated_x = max(0, vis_x - updated_col_width - col_gap)
        name_x = 0
        name_width = max(1, updated_x - name_x - 1)
        desc_width = max(1, name_width - 2)

        header_y = 4
        _safe_add(stdscr, header_y, name_x, _truncate("Name", name_width), name_width, accent_attr)
        _safe_add(stdscr, header_y, updated_x, "Updated".rjust(updated_col_width), updated_col_width, accent_attr)
        _safe_add(stdscr, header_y, vis_x, "Visibility".rjust(vis_col_width), vis_col_width, accent_attr)

        row_height = 2 if height >= 16 else 1
        top = header_y + 1
        footer_rows = 2
        window_size = max(1, (height - top - footer_rows) // row_height)
        end = min(offset + window_size, len(filtered))
        row_y = top
        for idx in range(offset, end):
            repo = filtered[idx]
            selected_row = idx == selected
            row_attr = selected_attr if selected_row else curses.A_NORMAL
            marker = ">" if selected_row else " "
            visibility = "private" if repo.is_private else "public"
            updated = _format_relative_time(repo.updated_at)
            repo_line = f"{marker} {repo.full_name}"
            _draw_with_highlight(stdscr, row_y, name_x, repo_line, name_width, query, row_attr, match_attr)
            _safe_add(
                stdscr,
                row_y,
                updated_x,
                _truncate(updated, updated_col_width).rjust(updated_col_width),
                updated_col_width,
                row_attr | curses.A_DIM,
            )
            _safe_add(
                stdscr,
                row_y,
                vis_x,
                visibility.rjust(vis_col_width),
                vis_col_width,
                (row_attr | badge_attr) if not selected_row else row_attr,
            )

            if row_height > 1:
                description = repo.description or ""
                current_desc_offset = desc_offsets.get(repo.full_name, 0) if selected_row else 0
                max_repo_desc_offset = max(0, len(description) - desc_width)
                if current_desc_offset > max_repo_desc_offset:
                    current_desc_offset = max_repo_desc_offset
                    if selected_row:
                        desc_offsets[repo.full_name] = current_desc_offset
                description_view = _description_view(description, current_desc_offset, desc_width)
                _draw_with_highlight(
                    stdscr,
                    row_y + 1,
                    2,
                    _truncate(description_view, desc_width),
                    desc_width,
                    query,
                    row_attr | curses.A_DIM,
                    match_attr,
                )
            row_y += row_height

        if not filtered:
            _safe_add(stdscr, top, 0, "No repositories match your search.", max(1, width - 1), curses.A_DIM)
            footer = "Showing 0 results"
        else:
            footer = f"Showing {offset + 1}-{end} of {len(filtered)}"
        hints = "Enter: clone   Up/Down: move   PgUp/PgDn: page   Left/Right: desc scroll   Backspace: edit search   Esc: cancel"
        _safe_add(stdscr, height - 2, 0, _truncate(footer, width - 1), max(1, width - 1), accent_attr)
        _safe_add(stdscr, height - 1, 0, _truncate(hints, width - 1), max(1, width - 1))
        stdscr.refresh()

        key = stdscr.getch()
        if key == 3:
            raise KeyboardInterrupt
        if key == 27:
            return None

        if key in (curses.KEY_UP,) and filtered:
            selected = max(0, selected - 1)
        elif key in (curses.KEY_DOWN,) and filtered:
            selected = min(len(filtered) - 1, selected + 1)
        elif key in (curses.KEY_NPAGE,) and filtered:
            selected = min(len(filtered) - 1, selected + window_size)
        elif key in (curses.KEY_PPAGE,) and filtered:
            selected = max(0, selected - window_size)
        elif key in (curses.KEY_RIGHT,) and row_height > 1 and filtered:
            selected_repo = filtered[selected]
            selected_desc = selected_repo.description or ""
            max_repo_desc_offset = max(0, len(selected_desc) - desc_width)
            current_desc_offset = desc_offsets.get(selected_repo.full_name, 0)
            if current_desc_offset < max_repo_desc_offset:
                desc_offsets[selected_repo.full_name] = current_desc_offset + 1
        elif key in (curses.KEY_LEFT,) and row_height > 1 and filtered:
            selected_repo = filtered[selected]
            current_desc_offset = desc_offsets.get(selected_repo.full_name, 0)
            if current_desc_offset > 0:
                desc_offsets[selected_repo.full_name] = current_desc_offset - 1
        elif key in (curses.KEY_ENTER, 10, 13) and filtered:
            return filtered[selected]
        elif key in (curses.KEY_BACKSPACE, 127, 8):
            if query:
                query = query[:-1]
                selected = 0
                offset = 0
        elif key == 21:  # Ctrl+U
            query = ""
            selected = 0
            offset = 0
        elif key == ord("/"):
            query = ""
            selected = 0
            offset = 0
        elif 32 <= key <= 126:
            query += chr(key)
            selected = 0
            offset = 0

        if selected < offset:
            offset = selected
        elif selected >= offset + window_size:
            offset = selected - window_size + 1


def choose_repository(repos: list[Repo]) -> Repo | None:
    try:
        return curses.wrapper(_chooser, repos)
    finally:
        # Best-effort terminal recovery for abrupt exits (e.g. Ctrl+C).
        try:
            curses.nocbreak()
            curses.echo()
            curses.endwin()
        except curses.error:
            pass
        try:
            curses.curs_set(1)
        except curses.error:
            pass


def clone_repository(full_name: str, folder: str) -> int:
    try:
        proc = subprocess.run(["gh", "repo", "clone", full_name, folder], check=False)
        return proc.returncode
    except FileNotFoundError:
        print("Error: GitHub CLI 'gh' is not installed or not in PATH.", file=sys.stderr)
        return 1


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="cri",
        description="Clone Repository Interactive using GitHub CLI.",
    )
    parser.add_argument(
        "owner",
        nargs="?",
        help="GitHub username or organization. Defaults to your account.",
    )
    args = parser.parse_args()

    if shutil.which("gh") is None:
        print("Error: 'gh' command not found. Install GitHub CLI first.", file=sys.stderr)
        return 1

    print("Starting... loading repositories from GitHub.", flush=True)
    try:
        repos = fetch_repositories(args.owner)
        if not repos:
            target = args.owner or "your account"
            print(f"No repositories found for {target}.")
            return 0

        chosen = choose_repository(repos)
        if not chosen:
            print("Cancelled.")
            return 0

        default_folder = chosen.name
        value = input(f"Destination folder [{default_folder}]: ").strip()
        folder = value or default_folder

        if os.path.exists(folder):
            print(f"Error: destination '{folder}' already exists.", file=sys.stderr)
            return 1

        return clone_repository(chosen.full_name, folder)
    except KeyboardInterrupt:
        print("\nCancelled.")
        return 130


if __name__ == "__main__":
    sys.exit(main())
